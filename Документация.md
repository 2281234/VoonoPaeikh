VoonoPaeikh -- библиотека на C++ для создания консольных игр.

При подключении VoonoPaeikh, также подключаются стандартные библиотеки
iostream, vector, windows.h, string, map, fstream, algorithm, map. В
VoonoPaeikh имеется 6 классов для работы:\
1. **Colorsy** -- класса для хранения цвета символа.\
***Поля***:

\
**unsigned char symbol** -- поле для хранения код цвета символа;

**unsigned char back** -- поле для хранения код цвета фона;

также имеются статические константы для 16 цветов, от чёрного до
ярко-белого.

\
***Методы***:

\
**colorsy() **-- конструктор colorsy с белым символом и чёрным фоном;

**colorsy(unsigned char colorSymbol, unsigned char backColor)** --
конструктор принимающий цвет символа и цвет фона(colorSymbol и backColor
соответственно);

\
**void operator=(colorsy color)** -- задаёт colorsy поля symbol и back
такими же как и у операнта color;

\
**bool operator==(colorsy color)** -- возвращает true если поля symbol и
back у обоих оперантов совпадают;

**bool operator!=(colorsy color)** -- возвращает false если поля symbol
и back у обоих оперантов совпадают;

2\. **cell** -- класс для хранения клетки экрана.\

***Поля***:

\
**unsigned char symbol** -- хранит символ записанный в клетку;\
**colorsy color **-- хранит цвет клетки.

***Методы:***

**cell(unsigned char symb, unsigned char colorSymbol, unsigned char
backColor)** -- конструктор с символом, цветом символа и цветом фона;

**cell() **-- конструктор задающий symbol = \' \'; color.symbol =
colorsy::WHITE; color.back = colorsy::BLACK;

**cell(unsigned char symb, colorsy clr)** -- конструктор принимающий
символ и цвет;\
Оператор= задаёт поля symbol и color такие же, как и у второго операнта.

3\. **element** -- абстрактный класс для игровых элементов.

***Поля***:

\
**int xpos** -- позиция по оси X ;

**int ypos** -- позиция по оси Y ;

**std::vector\<std::vector\<colorsy\>\> color** -- двухмерный вектор для
цветов элемента.

*** Методы***:

**element()** -- задаёт координаты 0;0 ;

**void draw(std::vector\<std::vector\<cell\>\>& screen)** -- абстрактный
метод для отображения элемента на экране;

**void element::loadColor(std::string colorSymbol, std::string
backColor)** -- метод для задания цвета элементу, принцип работы:\
1. Открываются файлы с названиями colorSymbol и backColor (подходит
любой текстовый формат, но для удобстав лучше использовать .csg и .bcg
для colorSymbol и BackColor соответственно)

2\. тексты в файлах сохраняются в двухмерные векторы unsigned char

3\. используя глобальный словарь \<char, unsigned char\> CHAR_TO_COLOR
(преобразующий символ из файла в значение цвета) записывает значение в
color;

**setMonoColor(colorsy colora)** -- абстрактный метод для задания одного
цвета для всего элемента;

**drawBack(std::vector\<std::vector\<cell\>\>& screen)** -- абстрактный
метод для отрисовки только символов элемента;

**drawSymbol(std::vector\<std::vector\<cell\>\>& screen)** --
абстрактный метод для отрисовки только фона элемента;

**Операторы** не задаются для абстрактного element, но определяются в
дочерних классах, т.е. операторы нельзя использовать с объектами
element, но можно с его дочерними;

Символ \',\' не отрисовывается, это сделано для того, чтоб можно было
делать прозрачные части элементам.

4\. **rect** -- дочерний класс element для одно строчного текста.

***Поля***:

**std::string text** -- текст.

***Методы***:

**rect(std:: texta, std::vector\<colorsy\>& colora, int x, int y)** --
конструктор принимающий текст, двухмерный вектор colory и координаты;

**rect()** -- конструктор задающий text = ""; добавляющий в color
подвектор colorsy; и координаты 0;0 ;

**rect(std::string a, colorsy b, int x, int y)** -- text = a; все colosy
в color = b; координаты = x;y ;

**rect(std::string texta, int x, int y)** -- text = texta; координаты =
x;y ; color остаётся пустым;

операторы(=, == и !=) игнорируют координаты, т.е. оператор = присваивает
только поля text и color, а операторы == и != сравнивают только поля
text и color;

5\. **sprit** -- дочерний класс element для спрайтов псевдографики.

***Поля***:

**std::vector\<std::string\> image** -- изображение используемое для
спрайта

***Методы***:

**sprit(std::vector\<std::string\> texta,
std::vector\<std::vector\<colorsy\>\> colora, int x, int y)** -- image =
texta; color = colora; координаты = x;y ;

**sprit() **-- задаются только координаты 0;0 ;

sprit(std::vector\<std::string\> a, colorsy b, int x, int y);

sprit(int x, int y);

**void loadImpage(std::string filename)** -- загружает текстовый файл в
impage(подходит любой текстовый формат);

**int width()** -- возвращает ширину image;

**int height()** -- возвращает высоту image;

операторы(=, == и !=) игнорируют координаты, т.е. оператор = присваивает
только поля impage и color, а операторы == и != сравнивают только поля
impage и color;

6\. **game** -- класс для работы с конкретной игрой(переключение между
играми, не выходя из консоли, возможно).

***Поля***:

**static std::map\<int, time_t\> timeOfPress** и

**static std::map\<int, bool\> keyIsPressed** для GetKeyDown и GetKeyUp
соотвественно;

**std::vector\<std::vector\<cell\>\> screen** -- экран, на котором будут
отображаться элементы;

**std::vector\<element\*\> elements** -- список элементом игры(точнее,
указателей на них);

**unsigned int screenHeight и unsigned int screenWidth** для хранения
высоты и ширины экрана соответственно;

**void createScreen(int w, int h)** -- создаёт экран;

**void clearScreen()** -- очищает экран;

**long long indexSearchInElemets(element\* address)** -- возвращает
индекс указателя на элемент в elements;

**static bool GetKey(int vKey)** -- возвращает true пока клавиша нажата;

**static bool GetKeyDown(int vKey, time_t timeSleep)** -- единичный раз
возвращает true когда клавиша нажимается, timeSleep показывает
промежуток между срабатываниями если клавиша зажимается;

**static bool GetKeyUp(int vKey)** -- возвращает true если клавиша была
нажата, а затем отпущена;

**std::string outputScreen()** -- преобразует экран в строку для вывода
в консоль;

**void addElement(element\* elemy)** -- добавляет элемент в конец
elements;

**static void nuke()** -- завершает программу с ошибкой
-1073741819(0xC0000005) Access Violation;

Логика **операторов **отсутствует.

После ознакомления с стандартными классами библиотеки VoonoPaeikh, вы
готовы создать свою первую игру, рассмотрим пример с Hello World;\

#include "VoonoPaeikh.hpp"

int main () {

game HelloWorld;

HelloWorld.createScreen(200, 40);

rect\* hw = new rect("Hello World", colorsy(colorsy::WHITE,
colorsy::BLACK), 0, 0);

HelloWorld.addElement(hw);

while (true) {

HelloWorld.clearScreen();

HelloWorld.elements\[0\]-\>draw(HelloWorld.screen);

if (game::GetKey(\'A\')) {

hw-\>xpos -= 1;

}

if (game::GetKey(\'D\') {

hw-\>xpos += 1;

}

if (game::GetKeyDown(VK_SPACE, 100) {\
game::nuke();

}

Sleep(50);

}

}

1\. Для начала работы необходимо подключить заголовочный файл библиотеки
**VoonoPaeikh.hpp**

2\. Создаётся объекта HelloWorld класса game

3\. К HelloWorld создаётся экрана размерами 200 на 40

4\. Создаётся указатель на новую переменную класса rect с текстом «Hello
World», цветами белый-чёрный в координатах 0;0

5\. Добавляем hw в HelloWorld.elements

6\. В вечном цикле очищаем экран и рисуем hw

7\. Если нажата A, то двигаем hw влево, D -- вправо

8\. Если нажата клавиша пробел, то закрываем программу с помощью nuke()
(второй аргумент 100 показывает, что между считиваниями нажатия пробела
при зажатии будет проходит 100 секунд)

9\. После каждой отрисовки, ждём 50 мс перед следующей для контроля
частоты обновления кадров.

Желательно использовать метод draw и подобные для отрисовки перед
логикой, иначе управление будет ощущаться менее отзывчивым.
